# Vue 笔记

## 第一节

### 组件注册

* **main.js**里面注册的组件是全局注册的。
* 其它组件注册只能在本组件使用,不可以在其他组件使用
* vue中**@**为根目录的意思

#### props 组件通信

* 在使用子组件时 加一个一个变量传递参数
  列如: 使用在main.js注册的注册**app-cout** ``` <app-count :init="9"></app-count>  ```
  传递了一个变量init的变量 在子组件要接收这个值如``props:{init:{type:number,default:3}}`` 
  使用这个props来接收参数 **注意**这个props是只读的所以需要一个变量来data变量来接收这个变量
  
* props:['init'] 这样定义是数组参数，``props:{init:{type:number,default:3}}`` 这样定义是对象类型可以
  定义初始值**default**是定义初始值的，**type**是定义对象类型如:number,Sring,Array,Boole,Object 只有父组件没有传递值的情况下
  **default**才会生效，如果参数类型不匹配会报错。

  ```vue
  <script>
  export default {
    props: {
      init: {
        type: Number,
        default: 3,
        required:true,
       },
      },
     };
  </script>
  ```

* **required**是否必填属性为布尔值，一般不会和**default**一起用会有冲突。

* props是组件的**自定义属性**，在**封装组件**的时候，合理的使用props可以极大的**提高组件的复用性**

#### 组件之间的样式冲突

* 默认情况下**写在vue组件中的样式会全局生效**，因此很容易造成**多个组件的样式冲突问题**。
* 解决办法：
     * 给**style**添加属性**scoped** ``<style lang="less" scoped></style>``
     * Vue会基本算法自动在选择器前面**增加前缀** ``<h2 data-v-dd817fc8="">Right 组件</h2>``避免了样式冲突问题。
* 缺点: 
  * 加上**scoped**后父组件修改子组件样式**不会生效** 
  * 原理:父组件加上**scoped**后会增加一个前缀，所有样式表的选择器也会增加而**子组件不会有这个前缀**
  * 解决办法:
       * 在要选择的子组件选择器前面加个**/deep/ ** 加上以后会变成一个后代选择器 实现效果
         当使用第**三方组件库**的时候要**修改组件默认样式**的需求可以使用/deep/ **::v-deep**也可以实现 

### Vue组件的实例对象

* .VUE文件不能直接被浏览器解析，需要通过 ``vue-template-compiler``这个包来解析的

#### Vue的生命周期

* 生命周期(Life Cycle)是指一个组件从**创建**->**运行**->**销毁**的整个阶段，强调的是一个时间段。

* 生命周期函数:是由Vue提供的**内置函数**,会伴随者组件的生命周期,**自动按次序执行**。
  * 组件创建阶段
    * 组件创建阶段: beforeCreate 
    
    * 组件创建完成(当前只在内存创建完成): created 可以访问**props，data,methods数据可用**，
    
      模板结构不可用。通过在这个阶段发送Ajax来获取数据。**注意**：在这个阶段模板结构没有开始渲染
    
      **不可以操作Dom**。
    
    * 将要把组件渲染到浏览器: beforeMount 同样不可以操作dom，**几乎不用**
    
    * 开始渲染: mounted 操作Dom在这个生命周期里面操作，**经常使用**
    
  * 组件运行阶段
    * 在更新之前: beforeUpdate 每次数据发生改变都会触发这个函数，页面数据是新的但是数据是旧的。
    * 更新:update 这个阶段数据和结构都是最新的，已经修改完成
    
  * 组件销毁阶段
    * 在销毁之前:beforeDestory 将要销毁此组件 此时尚未销毁还在工作状态。此时还可以访问到data里面的数据。
    * 销毁:Destoryed 组件已经被销毁，完全销毁。

### 组件之间的数据共享

>在项目开发中，组件之间最常见的关系分为俩种:
>
>1. 父子关系
>2. 兄弟关系
>
>组件之间的三种数据共享
>
>1. 父向子传递数据
>2. 子向父传递数据
>3. 兄弟组件的数据共享

#### 父子组件之间的数据共享

##### 父向子传递数据

* 在子组件中声明**props**来声明变量，父组件使用子组件时在子组件上通过**:变量**来传值。简单类型是复制一份传递过去，

  对象是把对象的引用传递过去。 修改对象里面属性的值父组件里面的值也会改变。

* 注意：不要修改**props**的值，它的值是只读的。 

##### 子向父传递数据

* 子组件向父组件传递数据要使用自定义事件 、

  ```vue
    子组件方法里添加这个传递给父组件 this.$emit('numberchange',this.count)
    父组件 使用@自定义的名字来接受这个值在赋值给自身的数据 <Right @numberchange="getNewCout"></Right> 
     getNewCout(val) {this.coutFromSon = val;},
  ```

##### 兄弟组件的数据共享

* 在Vue2.x中，兄弟组件之间的数据共享的方案是**EventBus**
* 发送方导入eventBus，使用它的**$.emit**方式去发送数据，接收方使用它的**$.on**去接收数据
* **注意**为了一开始就使数据生效通常把接收的放到created **俩边的方法名要一致**

### ref引用


>ref用来辅助开发者不依赖Jquery的情况下，获取DOM元素或组件引用。
>
>每个Vue实例上，都包含一个$refs对象，里面存储着对应的Dom元素或组件的引用
>
>默认情况下，组件的$refs指向一个空对象

* refs的使用要在需要操作的dom元素的标签上添加**ref="h2"**属性，在方法中通过 ``this.$refs.h2.style.color="red"``

#### 使用ref引用组件

* 如果在父组件想使用子组件的方法,可用在父组件使用子组件的时候加上ref的属性 在父组件的方法上使用``this.$refs.属性名.子组件的方法``

* **this.$nexTick(cb)** 在一个方法中需要显示dom元素后操作这个dom的属性需要使用这个函数 列如：

* ```vue
  //显示文本框
  this.isShow = true;
  //获取焦点
  this.$nextTick(() => {this.$refs.iptRef.focus();});
  ```

* 组件的**this.$nexTick(cb)**方法，会把cb回调推迟到下一个Dom更新周期之后执行。通俗来说等组件加载完成在cb的回调函数，来保证不会出现找不到dom

### 数组的方法

* 数组的forEach方法 循环**一旦开始就无法停止**。 列如要在一个数组中找到某一个属性的下标位置。当找到之后还会在往后执行。
* some方法可以停止 通过``return trun``

* every方法 判断是否满足选项 例如：数组的每个属性都有一个布尔值来判断它们是否都是true 如果有一项不为true那么返回值为false
  <img src="https://oss.mrsong.top/typora/vue/image-20240408153259705.png" alt="image-20240408153259705" style="zoom: 67%;" />
* reduce方法把每一次循环的结果累加起来 语法格式如下图
  ![image-20240408154209205](https://oss.mrsong.top/typora/vue/image-20240408154209205.png) 
    <img src="https://oss.mrsong.top/typora/vue/image-20240408154431649.png" alt="image-20240408154431649" style="zoom: 80%;" />
